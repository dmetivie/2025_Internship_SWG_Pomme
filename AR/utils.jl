try
    using Distributions, Optim, LinearAlgebra, CSV, DataFrames 
    using Dates, CairoMakie, Statistics, Polynomials, StatsBase
catch ;
    import Pkg
    Pkg.add("Distributions")
    Pkg.add("Optim")
    Pkg.add("LinearAlgebra")
    Pkg.add("CSV")
    Pkg.add("DataFrames")
    Pkg.add("Dates")
    Pkg.add("CairoMakie")
    Pkg.add("Statistics")
    Pkg.add("Polynomials")
    Pkg.add("StatsBase")
    using Distributions, Optim, LinearAlgebra, CSV, DataFrames
    using Dates, CairoMakie, Statistics, Polynomials, StatsBase
end

"""
    Iyear(date::Vector{Date},year::Int)
Return a mask to select only the period of the year in argument.
"""
Iyear(date::Vector{Date},year::Int) = Date(year).<=date.<Date(year + 1)

"""
    RootAR(Φ::Vector)
Return the roots of the polynomial associated to the AR model given by Φ.
"""
RootAR(Φ::Vector)=roots(Polynomial([1;Φ]))

Month_vec=["January", "February", "March", "April", "May", "Jun", "July", "August", "September", "October", "November", "December"]

"""
    Log_Likelyhood_AR(x::Vector,Estimators::Vector)
Return the log-likelyhood of the x series, under the hypothesis that x is generated by an AR(p) 
model with Φ₁,Φ₂...Φₚ=Estimators[1:end-1], σ²=Estimators[end] and ε ~N(0,1).
This function does not consider the likelyhood of the initial conditiion x₁,x₂...xₚ
"""
function Log_Likelyhood_AR(x::Vector,Estimators::Vector)
    #!!Estimators[end]=σ^2
    p=length(Estimators)-1
    EV_vec=[dot(Estimators[1:end-1],x[(t-1):-1:(t-p)]) for t in (p+1):length(x)]
    return (-(length(x)-p)*(log(2π)+log(abs(Estimators[end]))) - sum((x[p+1:end] - EV_vec) .^2 )/Estimators[end] )/2
end

"""
    LL_AR_Estimation(x::Vector,p::Int)
Return the parameters of the AR(p) model on x, estimated with likelyhood computation. 
"""
function LL_AR_Estimation(x::Vector,p::Int)
    Estimators= [zeros(p) ; 1e-5]
    f(Estimators_) = - Log_Likelyhood_AR(x,Estimators_)
    Estimators=Optim.minimizer(optimize(f,Estimators))
    return Estimators[1:end-1] , Estimators[end]
end

"""
    LL_AR_Estimation_sum(x_vec::Vector,p::Int)
Return the parameters of the AR(p) model on multiple series in x_vec (x_vec must be a vector of vector), estimated with the sum of their likelyhood. 
"""
function LL_AR_Estimation_sum(x_vec::Vector,p::Int)
    Estimators= [zeros(p) ; 1e-5]
    f(Estimators_) = - sum([Log_Likelyhood_AR(x,Estimators_) for x in x_vec])
    Estimators=Optim.minimizer(optimize(f,Estimators))
    return Estimators[1:end-1] , Estimators[end]
end

"""
    simulation(x::Vector,Φ::Vector,σ::Number,n::Int)
Return a simulation of n steps of an AR(p) model with parameters Φ, standard deviation of noise σ and initial condition x.
"""
function simulation(x::Vector,Φ::Vector,σ::Number,n::Int)
    y,p=copy(x),length(x)
    return simulation!(x,Φ,σ,n,y,p)
end
function simulation!(x::Vector,Φ::Vector,σ,n,y,p)
    for _ in 1:n
        append!(y, dot(y[end:-1:end-p+1],Φ) + σ * randn())
    end
    return y[p+1:end]
end
simulation(x::Number,Φ::Number,σ,n) = simulation([x],[Φ],σ,n)

"""
    sample_simulation(x::Vector,Φ::Vector,σ::Number,n_year::Int,periodicity::Vector)
Return a sample of n_year*size_multiplicator annual simulations of weather, according to the AR(1) model. periodicity is the periodicity component we want to consider.
"""
function sample_simulation(x::Vector,Φ::Vector,σ::Number,periodicity::Vector,n_year::Int=1,size_multiplicator::Int=1)
    Output=[]
    p=length(x)
    for _ in 1:size_multiplicator
        simulated=simulation(x,Φ,σ,365*(n_year+1)-p) + periodicity[(1+p):365*(n_year+1)]
        append!(Output,[simulated[(365i+1-p):365*(i+1)-p] for i in 1:n_year]) #We do not put the first period
    end
    return Output
end
sample_simulation(x::Number,Φ::Number,σ::Number,periodicity::Vector,n_year::Int=1,size_multiplicator::Int=1)=sample_simulation(x[1],Φ[1],σ,n_year,periodicity,n_year,size_multiplicator)

"""
    SimulateMonth(x0,day_one,Φ_month,σ_month,n_month)
Return a simulation of a month-conditional AR(1) model (one AR(1) model for each month), for n_month starting from day_one with x0.
Unless day_one is the last day of his month, the current month of day_one is included in n_month.  
"""
function SimulateMonth(x0::Number,day_one::Date,Φ_month::Vector,σ_month::Vector,n_month::Int)
    current_month = Date(year(day_one),month(day_one))
    if current_month + Month(1) - Day(1) - day_one != Day(0) #If it is not the last day of the month
        n=length(day_one:(current_month + Month(1) - Day(1))) 
        x=[x0 ; simulation(x0,Φ_month[month(day_one)],σ_month[month(day_one)],n-1)]       
    else
        n=length(day_one:(current_month + Month(2) - Day(1)))
        x=[x0 ; simulation(x0,Φ_month[(month(day_one) + 1) % 12],σ_month[(month(day_one) + 1) % 12],n-1)]
        current_month += Month(1)
    end
    if n_month > 1 
        for _ in 2:n_month
            current_month += Month(1)
            n=length(current_month:current_month + Month(1) - Day(1))
            append!(x, simulation(x[end],Φ_month[month(current_month)],σ_month[month(current_month)],n))
        end
    end
    return x
end

"""
    invert(L::Vector)
Transpose a vector of vectors L (like the function zip in python)
"""
invert(L::Vector)=[[L[i][j] for i in eachindex(L)] for j in eachindex(L[1])]

"""
    MonthlySeparateDates(Date_vec::Vector{Date})
Reshape the vector of dates Date_vec into a vector of vectors of vectors Monthly_date. 
For Monthly_date[i][j][k], i ∈ 1:12 represents the month, j the year and k the day.
"""
function MonthlySeparateDates(Date_vec::Vector{Date})
    Monthly_date=[[] for _ in 1:12]
    for i in 1:12
        for year in unique(year.(Date_vec))
            if any(Date(year,i).<=Date_vec.<(Date(year,i) + Month(1)))
                append!(Monthly_date[i], [Date_vec[Date(year,i).<=Date_vec.<Date(year,i) + Month(1)]])
            end
        end
    end
    return Monthly_date
end

"""
    MonthlySeparateX(x::Vector,Date_vec::Vector{Date})
Reshape the vector of values x into a vector of vectors of vectors Monthly_temp. 
For Monthly_temp[i][j][k], i ∈ 1:12 represents the month, j the year and k the day, according to the calendar Date_vec.
"""
function MonthlySeparateX(x,Date_vec)
    Monthly_temp=[[] for _ in 1:12]
    for i in 1:12
        for year in unique(year.(Date_vec))
            if any(Date(year,i).<=Date_vec.<(Date(year,i) + Month(1)))
                append!(Monthly_temp[i], [x[Date(year,i).<=Date_vec.<(Date(year,i) + Month(1))]])
            end
        end
    end
    return Monthly_temp
end

"""
    Monthly_stats(stats::Function,Monthly_Estimators::Vector{Vector},type_param::Int=1)
For each month (i ∈ 1:12) applies the function stats to monthly_Estimators[i]
"""
function Monthly_stats(stats::Function,Monthly_Estimators,type_param=1)
    Output=[]
    for i in 1:12
        L=[month_param[type_param] for month_param in Monthly_Estimators[i]]
        append!(Output, type_param==1 ? [stats.(invert(L))] : stats(L) )
    end
    return Output
end