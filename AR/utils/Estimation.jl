include("utils.jl")

using Optimization, Dates, Statistics, StatsBase, DataFrames, LinearAlgebra, OptimizationOptimJL, ForwardDiff #,Zygote

##### ESTIMATION #####
"""
    Opp_Log_Likelihood_AR(x::AbstractVector,Estimators::AbstractVector)

Return the opposite of the log-likelihood of the x series, under the hypothesis that x is generated by an AR(p) 
model with Φ₁,Φ₂...Φₚ=Estimators[1:end-1], σ²=Estimators[end] and ε ~N(0,1). 
Caution : it is the only function where Estimators[end]=σ². In the all others functions Estimators[end]=σ.
This function does not consider the likelihood of the initial conditiion x₁,x₂...xₚ
"""
function Opp_Log_Likelihood_AR(Estimators::AbstractVector, x::AbstractVector)
    p = length(Estimators) - 1
    R = stack([x[(p+1-i):(end-i)] for i in 1:p]) #matrix where each row is like (Xₜ₋₁,Xₜ₋₂,...Xₜ₋ₚ)
    return ((length(x) - p) * (log(2π) + log(abs(Estimators[end]))) + transpose(x[p+1:end] - R * Estimators[1:(end-1)]) * (x[p+1:end] - R * Estimators[1:(end-1)]) / Estimators[end]) / 2
end
"""
    LL_AR_Estimation(x::AbstractVector,p::Integer)

Return the parameters of the AR(p) model on x, estimated with likelihood computation.
Estimators corresponds to the initialization of the algorithm.
"""
function LL_AR_Estimation(x::AbstractVector, p::Integer, Estimators::AbstractVector=[[0.5 for _ in 1:p]; 1e-15], algo=LBFGS())
    p == length(Estimators) - 1 ? nothing : error("p (=$(p)) is not equal to the number of Φ initial parameters (=$(length(Estimators)-1))")
    optf = OptimizationFunction(Opp_Log_Likelihood_AR, AutoForwardDiff())
    prob = OptimizationProblem(optf, Estimators, x, lb=[[-10 for _ in 1:p]; 1e-20], ub=[[10 for _ in 1:p]; 1e2])
    Results = Optimization.solve(prob, algo, maxiters=10000) #maxiters should be modified if needed
    return Results[1:end-1], abs(Results[end])^0.5
end

"""
    LL_AR_Estimation_sum(x_vec::AbstractVector,p::Integer)

Return the parameters of the AR(p) model on multiple series in x_vec (x_vec must be a vector of vector), estimated with the sum of their likelihood. 
"""
function LL_AR_Estimation_sum(x_vec::AbstractVector, p::Integer, Estimators::AbstractVector=[zeros(p); 1e-15], algo=LBFGS())
    p == length(Estimators) - 1 ? nothing : error("p (=$(p)) is not equal to the number of Φ initial parameters (=$(length(Estimators)-1))")
    f(Estimators_, x_vec) = sum(Opp_Log_Likelihood_AR(Estimators_, x) for x in x_vec)
    optf = OptimizationFunction(f, AutoForwardDiff())
    prob = OptimizationProblem(optf, Estimators, x_vec, lb=[[-10 for _ in 1:p]; 1e-20], ub=[[10 for _ in 1:p]; 1e2])
    Results = Optimization.solve(prob, algo, maxiters=10000)
    return Results[1:end-1], abs(Results[end])^0.5
end

"""
    Monthly_stats(stats::Function,Monthly_Estimators::AbstractVector{AbstractVector},type_param::Integer=1)

For each month (i ∈ 1:12) applies the function stats to monthly_Estimators[i]. 
type_param=1 assumes that Monthly_Estimators contains estimations of Φ and =2 assumes that Monthly_Estimators contains estimations of σ.
"""
function Monthly_stats(stats::Function, Monthly_Estimators, type_param=1)
    type_param ∈ [1, 2] ? nothing : error("Invalid value for type_param.")
    Output = []
    for i in 1:12
        L = [month_param[type_param] for month_param in Monthly_Estimators[i]]
        append!(Output, length(L[1]) != 1 ? [stats.(invert(L))] : stats(L))
    end
    return Output
end

"""
    MonthlyEstimation(Monthly_temp::AbstractVector,p::Integer=1,Estimators::AbstractVector=[zeros(p) ; 1e-5],algo=NelderMead())

Return the estimated parameters of an AR(p) on each month in Monthly_temp.
Estimators corresponds to the initialization of the optimization algorithm.
"""
function MonthlyEstimation(Monthly_temp::AbstractVector, p::Integer=1, Estimators::AbstractVector=[zeros(p); 1e-5], algo=LBFGS())
    Monthly_Estimators = [Tuple[] for _ in 1:12]
    for i in 1:12
        for x in Monthly_temp[i]
            Est = LL_AR_Estimation(x, p, Estimators, algo)
            append!(Monthly_Estimators[i], [tuple((p == 1 ? Est[1][1] : Est[1]), Est[2])])
        end
    end
    return Monthly_Estimators
end

"""
    MonthlyConcatanatedEstimation(Monthly_temp::AbstractVector,p::Integer=1,Estimators::AbstractVector=[zeros(p) ; 1e-5],algo=NelderMead())

Return the estimated parameters of an AR(p) for each month of the data in Monthly_temp, with months concatenations. 
For each month, the series considered is the concatanation of all series corresponding to this month.
For instance, if our original series start from 1950, the series considered for January will be the concatenation of January 1950, January 1951, January 1952, etc. 
Estimators corresponds to the initialization of the optimization algorithm.
"""
function MonthlyConcatanatedEstimation(Monthly_temp::AbstractVector, p::Integer=1, Estimators::AbstractVector=[zeros(p); 1e-5], algo=LBFGS())
    C_Monthly_temp = reduce.(vcat, Monthly_temp)
    Φ_month_concat = p == 1 ? AbstractFloat[] : Vector[]
    σ_month_concat = AbstractFloat[]
    for x in C_Monthly_temp
        Estimation = LL_AR_Estimation(x, p, Estimators, algo)
        append!(Φ_month_concat, p == 1 ? Estimation[1] : [Estimation[1]])
        append!(σ_month_concat, Estimation[2])
    end
    return (stack(Φ_month_concat), σ_month_concat)
end

"""
    MonthlyEstimationSumLL(Monthly_temp::AbstractVector,p::Integer=1,Estimators::AbstractVector=[zeros(p) ; 1e-5],algo=NelderMead())

Return the estimated parameters of an AR(p) for each month of the data in Monthly_temp, where the likelihood is calculated by summing the likelihood of same months. 
For instance, if our original series start from 1950, the likelihood considered to find the parameters of January will be the sum of the likelihoods of January 1950, January 1951, January 1952, etc. 
Estimators corresponds to the initialization of the optimization algorithm.
"""
function MonthlyEstimationSumLL(Monthly_temp::AbstractVector, p::Integer=1, Estimators::AbstractVector=[zeros(p); 1e-5], algo=LBFGS())
    Φ_month_sumLL = p == 1 ? AbstractFloat[] : Vector[]
    σ_month_sumLL = AbstractFloat[]
    for x_month in Monthly_temp
        Estimation = LL_AR_Estimation_sum(x_month, p, Estimators, algo)
        append!(Φ_month_sumLL, p == 1 ? Estimation[1] : [Estimation[1]])
        append!(σ_month_sumLL, Estimation[2])
    end
    return (stack(Φ_month_sumLL, dims=1), σ_month_sumLL)
end

#### THE MAIN METHOD USED ####
"""
    Opp_Log_Monthly_Likelihood_AR(Estimators::AbstractMatrix, x::AbstractVector, date_vec::AbstractVector{Date})

Return the opposite of the log-likelihood of the x series, under the hypothesis that x is generated by an AR(p) 
model with differents set of parameters for each month. For exemple, for the iᵗʰ month, the paramaters are : 
Φ₁,Φ₂...Φₚ=Estimators[i,1:end-1] and σ²=Estimators[i,end].  
This function does not consider the likelihood of the initial conditiion x₁,x₂...xₚ
"""
function Opp_Log_Monthly_Likelihood_AR(Estimators::AbstractMatrix, x::AbstractVector, n2m, p, N)
    EV = [sum(Estimators[n2m[t], i] * x[t-i] for i in 1:p) for t in p+1:N] #Xₜ = EV(t) + ε in our model
    Opplogpdf(t) = (log(2π * abs(Estimators[n2m[t], end])) + ((x[t] - EV[t-p])^2) / Estimators[n2m[t], end]) / 2
    return sum(Opplogpdf.((p+1):N))
end
Opp_Log_Monthly_Likelihood_AR(Estimators::AbstractMatrix, tuple_::Tuple) = Opp_Log_Monthly_Likelihood_AR(Estimators, tuple_[1], tuple_[2], tuple_[3], tuple_[4])

"""
    LL_AR_Estimation_monthly(x_vec::AbstractVector,p::Integer)

Return the parameters of the AR(p) model on x with a set of parameter for each month. 
"""
function LL_AR_Estimation_monthly(x::AbstractVector, date_vec::AbstractVector{Date}, p::Integer, Estimators::AbstractMatrix=stack([[[0.5 for _ in 1:p]; 1e-15] for _ in 1:12], dims=1), algo=LBFGS(); Nb_try=0)
    lb = stack([[[-10 for _ in 1:p]; 1e-20] for _ in 1:12], dims=1)
    ub = stack([[[10 for _ in 1:p]; 1e2] for _ in 1:12], dims=1)
    p == size(Estimators)[2] - 1 ? nothing : error("p (=$(p)) is not equal to the number of Φ initial parameters (=$(length(Estimators)-1))")
    optf = OptimizationFunction(Opp_Log_Monthly_Likelihood_AR, AutoForwardDiff())
    prob = OptimizationProblem(optf, Estimators, (x, month.(date_vec), p, length(x)), lb=lb, ub=ub)
    Results = Optimization.solve(prob, algo, maxiters=10000) #maxiters should be modified if needed
    if !SciMLBase.successful_retcode(Results.retcode)
        @warn "Fail solve"
    end
    # if Nb_try > 0
    for i in 1:Nb_try
        Estimators = rand(12, p + 1) #Reinitialize the parameters
        prob = OptimizationProblem(optf, Estimators, (x, month.(date_vec), p, length(x)), lb=lb, ub=ub)
        localResults = Optimization.solve(prob, algo, maxiters=10000) #maxiters should be modified if needed
        if !SciMLBase.successful_retcode(Results.retcode)
            @warn "Fail solve iteration $(i)"
        end
        if localResults.objective < Results.objective
            Results = localResults
            @info "New best result found with new initialization at iteration $(i)"
        end
    end
    # end
    return Results[:, 1:p], Results[:, p+1] .^ (1 / 2)
end


############


"""
    GridEstimation(Estimationfunc::Function, Monthly_temp::AbstractVector , Φ_init, σ_init; sigma_est::Bool=false, p::Integer=1, algo=NelderMead())

Return a table of the estimation of an AR(p) model where each row corresponds to an initialization with a σ in σ_init and each column to a initialization with a Φ in Φ_init. 
If sigma_est is true, the values returned are the estimations of σ. If true_param is not nothing, the values returned are the mean absolute percentage error (MAPE) between the parameters estimated and the true parameters input.  
"""
function GridEstimation(Estimationfunc::Function, Monthly_temp::AbstractVector, Φ_init, σ_init, true_param=nothing; sigma_est::Bool=false, p::Integer=1, algo=LBFGS())
    if (true_param !== nothing) && (length(true_param) == 12) #For now we do not consider AR(12) models
        NewEstimationfunc(Monthly_temp, p, Estimators, algo) =
            (MAPE(Estimationfunc(Monthly_temp, p, Estimators, algo)[1], true_param),
                MAPE(Estimationfunc(Monthly_temp, p, Estimators, algo)[2], true_param))
    else
        NewEstimationfunc = Estimationfunc
    end

    Φ_names = ["$(Φ)" for Φ in Φ_init]
    type_param = sigma_est ? 2 : 1
    df = DataFrame([[[σ_init[1]]]; [[NewEstimationfunc(Monthly_temp, p, [Φ; σ_init[1]], algo)[type_param]] for Φ in Φ_init]],
        [raw"σ_init² ↓ | Φ_init →"; Φ_names])
    for σ in σ_init[2:end]
        push!(df, [σ; [NewEstimationfunc(Monthly_temp, p, [Φ; σ], algo)[type_param] for Φ in Φ_init]])
    end

    if length(df[1, 2]) == 1
        try
            f_index(x) = x[1]
            df[!, 2:end] = f_index.(df[!, 2:end])
        catch
            nothing
        end
    end

    if (true_param !== nothing) && (length(true_param) != 12)
        f_error(x) = MAPE(x, true_param)
        df[!, 2:end] = f_error.(df[!, 2:end])
    end

    return df
end


"""
    AddTrueParam(Parameters_vec::AbstractVector, TrueParamVec)

Add the true parameters to a list of estimated parameters (like an output of AllEstimation().
More precisely, for Parameters_vec = [[Φ1_month_vec,Φ1_month_concat,Φ1_month_sumLL],[Φ2_month_vec,Φ2_month_concat,Φ2_month_sumLL],...,[σ_month_vec,σ_month_concat,σ_month_sumLL]]
and TrueParamVec = [Φ1_true_param,Φ2_true_param,...σ_true_param] the function return 
[[Φ1_month_vec,Φ1_month_concat,Φ1_month_sumLL,Φ1_true_param],[Φ2_month_vec,Φ2_month_concat,Φ2_month_sumLL,Φ2_true_param],...,[σ_month_vec,σ_month_concat,σ_month_sumLL,σ_true_param]].
"""
AddTrueParam(Parameters_vec::AbstractVector, TrueParamVec) = [[Parameters; [TrueParamVec[i]]] for (i, Parameters) in enumerate(Parameters_vec)]

include("Separation.jl")
include("Plotting.jl")

"""
    TableError(Parameters_vec::AbstractVector,stats="mean")

Return a table of the mean absolute percentage error (MAPE) of each parameters estimated with every methods. 
The input must be like [[Φ1_month_vec,Φ1_month_concat,Φ1_month_sumLL,Φ1_month_MLL,Φ1_month_mean,Φ1_month_median,Φ1_true_param],
[Φ2_month_vec,Φ2_month_concat,Φ2_month_sumLL,Φ2_month_MLL,Φ2_month_mean,Φ2_month_median,Φ2_true_param],
...,[σ_month_vec,σ_month_concat,σ_month_sumLL,σ_month_MLL,σ_month_mean,σ_month_median,σ_true_param]]
(Param)_month_mean and (Param)_month_median are not mandatory, but if only one of the two is include, you must precise the type of statistic in "stats" variable ("mean" or "median").
"""
function TableError(Parameters_vec::AbstractVector, stats="mean")
    colnames = ["Parameter", "Month concatanation", "Sum LL", "Monthly LL"]
    if length(Parameters_vec[1]) == 6
        append!(colnames, "$(stats) of monthly parameters")
    elseif length(Parameters_vec[1]) == 7
        append!(colnames, ["mean of monthly parameters", "median of monthly parameters"])
    end
    print(length(Parameters_vec[1]))
    df = DataFrame([[["Φ1"]]; [[MAPE(method, Parameters_vec[1][end])] for method in Parameters_vec[1][2:end-1]]], colnames)
    for (i, Parameters) in enumerate(Parameters_vec[2:end-1])
        push!(df, ["Φ$(i+1)"; [MAPE(method, Parameters[end]) for method in Parameters[2:end-1]]])
    end
    push!(df, ["σ"; [MAPE(method, Parameters_vec[end][end]) for method in Parameters_vec[end][2:end-1]]])
    return df
end

"""
    AllEstimation(Monthly_temp::AbstractVector,p::Integer=1,Estimators::AbstractVector=[zeros(p) ; 1e-5],algo=NelderMead(),Date_vec=nothing)

Applies the three monthly AR(p) estimation methods on x. x can be an output of MonthlySeparateX or directly the whole series. In this last case, Date_vec must be put in argument.
The j-th component of the list is a vector like [Φj_month_vec,Φj_month_concat,Φj_month_sumLL]
"""
function AllEstimation(x::AbstractVector, p::Integer=1; Estimators::AbstractVector=[zeros(p); 1e-5], algo=LBFGS(), Date_vec=nothing, TrueParamVec=nothing, plot=true, meanparam=true, medianparam=true, ErrorTable=false, PerMethod=false, lineplot=false)
    Monthly_temp = isnothing(Date_vec) ? copy(x) : MonthlySeparateX(x, Date_vec)
    ErrorTable = isnothing(Date_vec) ? false : ErrorTable

    ParamOutput = Vector[]

    Monthly_Estimators = MonthlyEstimation(Monthly_temp, p, Estimators, algo) #Monthly_Estimators[i][j][k][l] i-> month, j-> year, k-> 1 for [Φ_1,Φ_2,...], 2 for σ, l -> index of the parameter (Φⱼ) of year if k=1
    Month_vecs = [[[month_param[1][k] for month_param in Monthly_Estimators[i]] for i in 1:12] for k in 1:p]
    append!(Month_vecs, [[[month_param[2] for month_param in Monthly_Estimators[i]] for i in 1:12]]) #Month_vecs[i][j][k] i-> index of the parameter (Φᵢ) or (σ) if i=p+1, j-> month,  k -> year
    append!(ParamOutput, [Month_vecs])

    Φ_month_concat, σ_month_concat = MonthlyConcatanatedEstimation(Monthly_temp, p) #Φ_month_concat[i][j] : i-> month, j-> index of the parameter (Φⱼ) or (σ)
    append!(ParamOutput, [[eachcol(Φ_month_concat); [σ_month_concat]]])

    Φ_month_sumLL, σ_month_sumLL = MonthlyEstimationSumLL(Monthly_temp, p)
    append!(ParamOutput, [[eachcol(Φ_month_sumLL); [σ_month_sumLL]]])

    if !isnothing(Date_vec)
        Φ_month_MLL, σ_month_MLL = LL_AR_Estimation_monthly(x, Date_vec, p)
        append!(ParamOutput, [[eachcol(Φ_month_MLL); [σ_month_MLL]]])
    end

    #ParamOutput[i][j] : i -> method, j -> index of the parameter (Φⱼ) or (σ)
    # =Output or Output[1] if PerMethod = true

    Output = plot ? [ParamOutput, PlotParameters(isnothing(TrueParamVec) ? invert(ParamOutput) : invert([ParamOutput; [TrueParamVec]]), lineplot, !isnothing(Date_vec))] : [ParamOutput]

    meanparam ? append!(Output[1], [[mean.(Param) for Param in Output[1][1]]]) : nothing #p vectors param, param has a length of 12 ; param = Month_vecs[i]
    medianparam ? append!(Output[1], [[median.(Param) for Param in Output[1][1]]]) : nothing

    isnothing(TrueParamVec) ? nothing : append!(Output[1], [TrueParamVec])

    if length(Output) == 1
        Output = Output[1]
        PerMethod ? nothing : Output = invert(Output) #that is to say Output[i][j] : i -> index of the parameter (Φᵢ) or (σ), j -> method 
        ErrorTable ? Output = [[Output]; TableError(Output, (medianparam && !meanparam) ? "median" : "mean")] : nothing
    else
        PerMethod ? nothing : Output[1] = invert(Output[1])
        ErrorTable ? Output = [Output; TableError(Output[1], (medianparam && !meanparam) ? "median" : "mean")] : nothing
    end

    return Output
end

"""
    TakeParameters(Parameters_vec::AbstractVector,method::String="mean")

From an output of AllEstimation() (the parameters part if it's a tuple), return the Parameters from the method indicated as a tuple like (Φ_vec, σ_vec)
with Φ_vec like [[Φ_1_jan,Φ_2_jan,...Φ_p_jan], [Φ_1_feb,Φ_2_feb,...Φ_p_feb], etc.]. method must be a string in this list : 
["mean","median","concat","sumLL","TrueParam"]
"""
function TakeParameters(Parameters_vec::AbstractVector, method::String="mean")
    Parameters_vec = invert(Parameters_vec)
    if method == "mean"
        raw = Parameters_vec[end-1-(method=="TrueParam")]
    elseif method == "median"
        raw = Parameters_vec[end-(method=="TrueParam")]
    elseif method == "concat"
        raw = Parameters_vec[2]
    elseif method == "sumLL"
        raw = Parameters_vec[3]
    elseif method == "monthlyLL"
        raw = Parameters_vec[4]
    elseif method == "TrueParam"
        raw = Parameters_vec[end]
    end
    return invert(raw[1:end-1]), raw[end]
end

"""
    AutoTakeParameters(AE_output)

From an output of AllEstimation(), return the Parameters from the most accurate method indicated as a tuple like (Φ_vec, σ_vec)
with Φ_vec like [[Φ_1_jan,Φ_2_jan,...Φ_p_jan], [Φ_1_feb,Φ_2_feb,...Φ_p_feb], etc.]. 
"""
function AutoTakeParameters(AE_output)
    MethodVector = ["concat", "sumLL", "monthlyLL", "mean", "median"]
    i = argmin(Array(mapcols(mean, AE_output[end][!, 2:end]))[1, :])
    return TakeParameters(AE_output[1], MethodVector[i])
end
AutoTakeParameters(Parameters_vec, ErrorTable) = AutoTakeParameters([Parameters_vec, ErrorTable])


Opp_Log_Monthly_Likelihood_AR(Model::MonthlyAR, z, n2m, p, N) = Opp_Log_Monthly_Likelihood_AR(hcat(Model.Φ, Model.σ .^ 2), z, n2m, p, N)


function Opp_Log_Monthly_Likelihood_AR_nspart(model::MonthlyAR, z, n2m, p, N)
    nspart = model.trend .+ model.period[dayofyear_Leap.(model.date_vec)]
    σ_nspart = model.σ_trend .* model.σ_period[dayofyear_Leap.(model.date_vec)]
    x = @views (nspart+σ_nspart.*z)[(p+1):N]
    Var = @views ((σ_nspart.*model.σ[n2m]) .^ 2)[(p+1):N]
    EV = [(nspart[t] + σ_nspart[t] * sum(model.Φ[n2m[t], i] * z[t-i] for i in 1:p)) for t in p+1:N] #Xₜ = EV(t) + ε in our model
    Opplogpdf = (log.(2π .* Var) + ((x .- EV).^2) ./ Var) / 2
    return sum(Opplogpdf)
end