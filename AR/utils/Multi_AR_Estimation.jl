include("utils.jl")

@tryusing "Optimization", "Dates", "Statistics", "StatsBase", "DataFrames", "LinearAlgebra", "OptimizationOptimJL", "ForwardDiff" #,"Zygote"


function FillByDiags!(v, Indexes, d)
    return (diagm(((i => v[Indexes[-i+1]+1:Indexes[-i+2]]) for i in -(d - 1):0)...))
end

function FillByDiags(v, d)
    Indexes = [0; cumsum(d:-1:1)]
    return (FillByDiags!(v, Indexes, d))
end

"""
    Opp_Log_Likelihood_AR(x::AbstractVector,Estimators::AbstractVector)

Return the opposite of the log-likelihood of the x matrix-series, under the hypothesis that x is generated by an multiple AR(p) 
(model with Φ₁,Φ₂...Φₚ=Estimators[1:end-1], σ²=Estimators[end] and ε ~N(0,1). )
(Caution : it is the only function where Estimators[end]=σ². In the all others functions Estimators[end]=σ.
This function does not consider the likelihood of the initial conditiion x₁,x₂...xₚ)
"""
function Opp_LL_Multi_AR!(Estimators::AbstractVector, x::AbstractArray)
    n, d = size(x)
    p = (2 * length(Estimators) - d^2 - d) ÷ (2 * d^2)
    Φ = [stack(Estimators[(j*(d^2)+1+i*d):(j*(d^2)+(i+1)*d)] for i in 0:(d-1)) for j in 0:(p-1)]
    Indexes = [0; cumsum(d:-1:1)]
    Σ = FillByDiags!(Estimators[(p*d^2+1):end], Indexes, d)
    Varcov = (Σ * transpose(Σ))
    InvVarcov = inv(Varcov)
    cte = d * log(2π) + log(abs(det(Varcov)))
    EV(t) = sum(Φ[j] * x[t-j, :] for j in 1:p)
    Opplogpdf(t) = (cte + transpose(x[t, :] - EV(t)) * InvVarcov * (x[t, :] - EV(t))) / 2
    return Opplogpdf, p, n
end


function Opp_LL_Multi_AR(Estimators::AbstractVector, x::AbstractArray)
    Opplogpdf, p, n = Opp_LL_Multi_AR!(Estimators, x)
    return sum(Opplogpdf.((p+1):n))
end

"""
    LL_Multi_AR_Estimation(x::AbstractVector,p::Integer)

Return the parameters of the AR(p) model on x, estimated with likelihood computation.
Estimators correspond to the initialization of the algorithm.
"""
function LL_Multi_AR_Estimation(x::AbstractArray, p::Integer, Estimators=nothing, algo=LBFGS())
    d = size(x)[2]
    InitΣ = [1e-5 * ones(d); 1e-15 * ones(d * (d - 1) ÷ 2)]
    isnothing(Estimators) ? Estimators = [[0.5 for _ in 1:p*d^2]; InitΣ] : nothing
    # p == length(Estimators) - 1 ? nothing : error("p (=$(p)) is not equal to the number of Φ initial parameters (=$(length(Estimators)-1))")
    optf = OptimizationFunction(Opp_LL_Multi_AR, AutoForwardDiff())
    prob = OptimizationProblem(optf, Estimators, x, lb=[[-10 for _ in 1:p*d^2]; [1e-20 for _ in 1:(d*(d+1)÷2)]], ub=[[10 for _ in 1:p*d^2]; [1e2 for _ in 1:(d*(d+1)÷2)]])
    Results = Optimization.solve(prob, algo) #maxiters should be modified if needed
    return Results
end


##### Monthly Estimation ######

"""
    Opp_Log_Likelihood_AR(x::AbstractVector,Estimators::AbstractVector)

Return the opposite of the log-likelihood of the x matrix-series, under the hypothesis that x is generated by an multiple AR(p) 
(model with Φ₁,Φ₂...Φₚ=Estimators[1:end-1], σ²=Estimators[end] and ε ~N(0,1). )
(Caution : it is the only function where Estimators[end]=σ². In the all others functions Estimators[end]=σ.
This function does not consider the likelihood of the initial conditiion x₁,x₂...xₚ)
"""
function Opp_LL_Monthly_Multi_AR!(Estimators::AbstractMatrix, tuple_)
    x, date_vec = tuple_
    n, d = size(x)
    p = (2 * size(Estimators)[2] - d^2 - d) ÷ (2 * d^2)
    Φ = [[stack(Estimators[m, (j*(d^2)+1+i*d):(j*(d^2)+(i+1)*d)] for i in 0:(d-1)) for j in 0:(p-1)] for m in 1:12]
    Indexes = [0; cumsum(d:-1:1)]
    InvVarcov, cte = AbstractMatrix[], Number[]
    for m in 1:12
        Σ = FillByDiags!(Estimators[m, (p*d^2+1):end], Indexes, d)
        Varcov = (Σ * transpose(Σ))
        push!(InvVarcov, inv(Varcov))
        push!(cte, d * log(2π) + log(abs(det(Varcov))))
    end
    EV(t) = sum(Φ[month(date_vec[t])][j] * x[t-j, :] for j in 1:p)
    Opplogpdf(t) = (cte[month(date_vec[t])] + transpose(x[t, :] - EV(t)) * InvVarcov[month(date_vec[t])] * (x[t, :] - EV(t))) / 2
    return Opplogpdf, p, n
end


function Opp_LL_Monthly_Multi_AR(Estimators::AbstractMatrix, tuple_)
    Opplogpdf, p, n = Opp_LL_Monthly_Multi_AR!(Estimators, tuple_)
    return sum(Opplogpdf.((p+1):n))
end

"""
    LL_Multi_AR_Estimation(x::AbstractVector,p::Integer)

Return the parameters of the AR(p) model on x, estimated with likelihood computation.
Estimators correspond to the initialization of the algorithm.
"""
function LL_Multi_AR_Estimation_monthly(x::AbstractArray, date_vec::AbstractVector{Date}, p::Integer, Estimators=nothing, algo=LBFGS())
    d = size(x)[2]
    InitΣ = [1e-5 * ones(d); 1e-15 * ones(d * (d - 1) ÷ 2)]
    isnothing(Estimators) ? Estimators = stack([[0.5 for _ in 1:p*d^2]; InitΣ] for _ in 1:12; dims=1) : nothing
    # p == length(Estimators) - 1 ? nothing : error("p (=$(p)) is not equal to the number of Φ initial parameters (=$(length(Estimators)-1))")
    optf = OptimizationFunction(Opp_LL_Monthly_Multi_AR, AutoForwardDiff())
    prob = OptimizationProblem(optf, Estimators, (x, date_vec),
        lb=stack([[-10 for _ in 1:p*d^2]; [1e-20 for _ in 1:(d*(d+1)÷2)]] for _ in 1:12; dims=1),
        ub=stack([[10 for _ in 1:p*d^2]; [1e2 for _ in 1:(d*(d+1)÷2)]] for _ in 1:12; dims=1))
    Results = Optimization.solve(prob, algo) #maxiters should be modified if needed
    return Results
end

function ParseMonthlyParameter(Param, d)
    p = (2 * size(Param)[2] - d^2 - d) ÷ (2 * d^2)

    Φ = [[stack(Param[m, (j*(d^2)+1+i*d):(j*(d^2)+(i+1)*d)] for i in 0:(d-1)) for j in 0:(p-1)] for m in 1:12] #12-element Vector{Vector{Matrix{Float64}}} ~16 min

    Indexes = [0; cumsum(d:-1:1)]
    Σ = [FillByDiags!(Param[m, (p*d^2+1):end], Indexes, d) for m in 1:12]

    return Φ, Σ
end

TakeMonthlyParameter(MatVec::Vector{Vector{Matrix{T}}}, IndexTuple, p=1) where T<:AbstractFloat = [MatVec[m][p][IndexTuple[1], IndexTuple[2]] for m in 1:12]
TakeMonthlyParameter(MatVec::Vector{Matrix{T}}, IndexTuple) where T<:AbstractFloat = [MatVec[m][IndexTuple[1], IndexTuple[2]] for m in 1:12]


#### Daily Parameters estimation ####

Poly_Trigo(t, Θ, K, ω=2π / 365.2422) = Θ[1] .+ sum(Θ[2:2:2K] .* cos.(ω * t * (1:K))) .+ sum(Θ[3:2:(2K+1)] .* sin.(ω * t * (1:K)))

"""
    Opp_Log_Likelihood_AR(x::AbstractVector,Estimators::AbstractVector)

Return the opposite of the log-likelihood of the x matrix-series, under the hypothesis that x is generated by an multiple AR(p) 
(model with Φ₁,Φ₂...Φₚ=Estimators[1:end-1], σ²=Estimators[end] and ε ~N(0,1). )
(Caution : it is the only function where Estimators[end]=σ². In the all others functions Estimators[end]=σ.
This function does not consider the likelihood of the initial conditiion x₁,x₂...xₚ)
"""
function Opp_LL_Daily_Multi_AR!(Estimators::AbstractVector, tuple_)
    x, date_vec, K = tuple_
    n2t = dayofyear_Leap.(date_vec)
    n, d = size(x)
    Indexes = [0; cumsum(d:-1:1)]
    d_sq = d^2
    p = (2 * length(Estimators) ÷ (2K + 1) - d_sq - d) ÷ (2 * d_sq)
    D_tri, ΦEndIndex = Indexes[end], d^2 * (2K + 1) * p

    Φ_vec = [[reshape(Estimators[(d_sq*(2K+1+i)*j+d_sq*i+1):(d_sq*(2K+1)*j+d_sq*(i+1))], (d, d)) for i in 0:2K] for j in 0:(p-1)]
    Φ = [map(t -> Poly_Trigo(t, Θ, K), 1:366) for Θ in Φ_vec]

    Σ = map(t -> Poly_Trigo(t, [FillByDiags!(Estimators[ΦEndIndex+D_tri*i+1:ΦEndIndex+D_tri*(1+i)], Indexes, d) for i in 0:2K], K), 1:366)
    Varcov = [Σ[t] * transpose(Σ[t]) for t in 1:366]
    InvVarcov = inv.(Varcov)
    cte = d * log(2π) .+ log.(abs.(det.(Varcov)))

    EV(t) = sum(Φ[j][n2t[t]] * x[t-j, :] for j in 1:p)
    Opplogpdf(t) = (cte[n2t[t]] + transpose(x[t, :] - EV(t)) * InvVarcov[n2t[t]] * (x[t, :] - EV(t))) / 2
    return Opplogpdf, p, n
end


function Opp_LL_Daily_Multi_AR(Estimators::AbstractVector, tuple_)
    Opplogpdf, p, n = Opp_LL_Daily_Multi_AR!(Estimators, tuple_)
    return sum(Opplogpdf.((p+1):n))
end

"""
    LL_Multi_AR_Estimation(x::AbstractVector,p::Integer)

Return the parameters of the AR(p) model on x, estimated with likelihood computation.
Estimators correspond to the initialization of the algorithm.
"""
function LL_Multi_AR_Estimation_daily(x::AbstractArray, date_vec::AbstractVector{Date}, p::Integer, K::Integer, Estimators=nothing, algo=LBFGS())
    d = size(x)[2]
    ΦEndIndex = (d^2) * (2K + 1) * p
    MaxIndex = ΦEndIndex + (2K + 1) * (d * (d + 1)) ÷ 2
    InitΣ = reduce(vcat, [1e-5 * ones(d); 1e-15 * ones(d * (d - 1) ÷ 2)] for _ in 0:2K)
    isnothing(Estimators) ? Estimators = [[0.5 for _ in 1:ΦEndIndex]; InitΣ] : nothing
    # p == length(Estimators) - 1 ? nothing : error("p (=$(p)) is not equal to the number of Φ initial parameters (=$(length(Estimators)-1))")
    optf = OptimizationFunction(Opp_LL_Daily_Multi_AR, AutoForwardDiff())
    prob = OptimizationProblem(optf, Estimators, (x, date_vec, K),
        lb=[[-10 for _ in 1:ΦEndIndex]; [1e-20 for _ in ΦEndIndex+1:MaxIndex]],
        ub=[[10 for _ in 1:ΦEndIndex]; [1e2 for _ in ΦEndIndex+1:MaxIndex]])
    Results = Optimization.solve(prob, algo) #maxiters should be modified if needed
    return Results
end

# function ParseDailyParameter(Param,d,K)
#     Indexes = [0; cumsum(d:-1:1)]
#     d_sq = d^2
#     p = (2 * length(Estimators) ÷ (2K + 1) - d_sq - d) ÷ (2 * d_sq)
#     D_tri, ΦEndIndex =  Indexes[end], d^2 * (2K + 1) * p

#     Φ = [[stack(Param[m, (j*(d^2)+1+i*d):(j*(d^2)+(i+1)*d)] for i in 0:(d-1)) for j in 0:(p-1)] for m in 1:12] #12-element Vector{Vector{Matrix{Float64}}} ~16 min

#     Indexes = [0; cumsum(d:-1:1)]
#     Σ = [FillByDiags!(Param[m, (p*d^2+1):end], Indexes, d) for m in 1:12]

#     return Φ,Σ
# end

# function TakeDailyParameter(ParamDaily,IndexTuple,p_order,d,K)
#     Indexes = [0; cumsum(d:-1:1)]
#     d_sq = d^2
#     p = (2 * length(Estimators) ÷ (2K + 1) - d_sq - d) ÷ (2 * d_sq)
#     D_tri, ΦEndIndex =  Indexes[end], d^2 * (2K + 1) * p
#     if p == 0 
#          M = map(t -> Poly_Trigo(t, [FillByDiags!(Estimators[ΦEndIndex+D_tri*i+1:ΦEndIndex+D_tri*(1+i)], Indexes, d) for i in 0:2K], K), 1:366)


function Opp_LL_Daily_Multi_AR2!(Estimators::AbstractVector, tuple_)
    x, date_vec, K = tuple_
    n2t = dayofyear_Leap.(date_vec)
    n, d = size(x)
    Indexes = [0; cumsum(d:-1:1)]
    d_sq = d^2
    p = (2 * length(Estimators) ÷ (2K + 1) - d_sq - d) ÷ (2 * d_sq)
    D_tri, ΦEndIndex = Indexes[end], d^2 * (2K + 1) * p

    Φ_vec = [[reshape(Estimators[(d_sq*((2K+1+i)*j+i)+1):(d_sq*((2K+1)*j+i+1))], (d, d)) for i in 0:2K] for j in 0:(p-1)]
    Φ = [map(t -> Poly_Trigo(t, Θ, K), 1:366) for Θ in Φ_vec]

    Σ = map(t -> Poly_Trigo(t, [FillByDiags!(Estimators[ΦEndIndex+D_tri*i+1:ΦEndIndex+D_tri*(1+i)], Indexes, d) for i in 0:2K], K), 1:366)
    Varcov = [Σ[t] * transpose(Σ[t]) for t in 1:366]
    InvVarcov = inv.(Varcov)
    cte = d * log(2π) .+ log.(abs.(det.(Varcov)))

    EV(t) = sum(Φ[j][n2t[t]] * x[t-j, :] for j in 1:p)
    Opplogpdf(t) = (cte[n2t[t]] + transpose(x[t, :] - EV(t)) * InvVarcov[n2t[t]] * (x[t, :] - EV(t))) / 2
    return Opplogpdf, p, n
end


function Opp_LL_Daily_Multi_AR2(Estimators::AbstractVector, tuple_)
    Opplogpdf, p, n = Opp_LL_Daily_Multi_AR2!(Estimators, tuple_)
    return sum(Opplogpdf.((p+1):n))
end

"""
    LL_Multi_AR_Estimation(x::AbstractVector,p::Integer)

Return the parameters of the AR(p) model on x, estimated with likelihood computation.
Estimators correspond to the initialization of the algorithm.
"""
function LL_Multi_AR_Estimation_daily2(x::AbstractArray, date_vec::AbstractVector{Date}, p::Integer, K::Integer, Estimators=nothing, algo=LBFGS())
    d = size(x)[2]
    ΦEndIndex = (d^2) * (2K + 1) * p
    MaxIndex = ΦEndIndex + (2K + 1) * (d * (d + 1)) ÷ 2
    InitΣ = reduce(vcat, [1e-5 * ones(d); 1e-15 * ones(d * (d - 1) ÷ 2)] for _ in 0:2K)
    isnothing(Estimators) ? Estimators = [[0.5 for _ in 1:ΦEndIndex]; InitΣ] : nothing
    # p == length(Estimators) - 1 ? nothing : error("p (=$(p)) is not equal to the number of Φ initial parameters (=$(length(Estimators)-1))")
    optf = OptimizationFunction(Opp_LL_Daily_Multi_AR2, AutoForwardDiff())
    prob = OptimizationProblem(optf, Estimators, (x, date_vec, K),
        lb=[[-10 for _ in 1:ΦEndIndex]; [1e-20 for _ in ΦEndIndex+1:MaxIndex]],
        ub=[[10 for _ in 1:ΦEndIndex]; [1e2 for _ in ΦEndIndex+1:MaxIndex]])
    Results = Optimization.solve(prob, algo) #maxiters should be modified if needed
    return Results
end




####3




function Opp_LL_Daily_Multi_AR3!(Estimators::AbstractVector, tuple_)
    x, d, p, K, n2t, ΦEndIndex, MaxIndex, Indexes, d_sq, D_tri = tuple_

    Φ_vec = [[reshape(Estimators[(d_sq*(2K+1+i)*j+d_sq*i+1):(d_sq*(2K+1)*j+d_sq*(i+1))], (d, d)) for i in 0:2K] for j in 0:(p-1)]
    Φ = [map(t -> Poly_Trigo(t, Θ, K), 1:366) for Θ in Φ_vec]

    Σ = map(t -> Poly_Trigo(t, [FillByDiags!(Estimators[ΦEndIndex+D_tri*i+1:ΦEndIndex+D_tri*(1+i)], Indexes, d) for i in 0:2K], K), 1:366)
    Varcov = [Σ[t] * transpose(Σ[t]) for t in 1:366]
    InvVarcov = inv.(Varcov)
    cte = d * log(2π) .+ log.(abs.(det.(Varcov)))

    EV(t) = sum(Φ[j][n2t[t]] * x[t-j, :] for j in 1:p)
    Opplogpdf(t) = (cte[n2t[t]] + transpose(x[t, :] - EV(t)) * InvVarcov[n2t[t]] * (x[t, :] - EV(t))) / 2
    return Opplogpdf
end


function Opp_LL_Daily_Multi_AR3(Estimators::AbstractVector, tuple_)
    p, n = tuple_[3], tuple_[end]
    return sum(Opp_LL_Daily_Multi_AR3!(Estimators, tuple_).((p+1):n))
end

"""
    LL_Multi_AR_Estimation(x::AbstractVector,p::Integer)

Return the parameters of the AR(p) model on x, estimated with likelihood computation.
Estimators correspond to the initialization of the algorithm.
"""
function LL_Multi_AR_Estimation_daily3(x::AbstractArray, date_vec::AbstractVector{Date}, p::Integer, K::Integer, Estimators=nothing, algo=LBFGS())
    n, d = size(x)
    n2t = dayofyear_Leap.(date_vec)
    d_sq = d^2
    ΦEndIndex = d_sq * (2K + 1) * p
    MaxIndex = ΦEndIndex + (2K + 1) * (d * (d + 1)) ÷ 2
    Indexes = [0; cumsum(d:-1:1)]
    D_tri = Indexes[end]

    tuple_ = x, d, p, K, n2t, ΦEndIndex, MaxIndex, Indexes, d_sq, D_tri, n

    InitΣ = reduce(vcat, [1e-5 * ones(d); 1e-15 * ones(d * (d - 1) ÷ 2)] for _ in 0:2K)
    isnothing(Estimators) ? Estimators = [[0.5 for _ in 1:ΦEndIndex]; InitΣ] : nothing
    # p == length(Estimators) - 1 ? nothing : error("p (=$(p)) is not equal to the number of Φ initial parameters (=$(length(Estimators)-1))")
    optf = OptimizationFunction(Opp_LL_Daily_Multi_AR3, AutoForwardDiff())
    prob = OptimizationProblem(optf, Estimators, tuple_,
        lb=[[-10 for _ in 1:ΦEndIndex]; [1e-20 for _ in ΦEndIndex+1:MaxIndex]],
        ub=[[10 for _ in 1:ΦEndIndex]; [1e2 for _ in ΦEndIndex+1:MaxIndex]])
    Results = Optimization.solve(prob, algo) #maxiters should be modified if needed
    return Results
end